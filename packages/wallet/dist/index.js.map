{
  "version": 3,
  "sources": ["../src/index.ts", "../src/keyPair.ts", "../src/wallet.ts", "../src/signatureVerification.ts"],
  "sourcesContent": ["// Export wallet functionality\nexport * from './keyPair';\nexport * from './wallet';\nexport * from './signatureVerification'; ", "import elliptic from 'elliptic';\nimport crypto from 'crypto';\n\n// Initialize elliptic curve - we'll use secp256k1 (same as Bitcoin)\nconst ec = new elliptic.ec('secp256k1');\n\n/**\n * Type definition for a key pair\n */\nexport type KeyPair = {\n  privateKey: string;\n  publicKey: string;\n};\n\n/**\n * Generates a new cryptographic key pair\n */\nexport const generateKeyPair = (): KeyPair => {\n  // Generate a new key pair\n  const keyPair = ec.genKeyPair();\n  \n  // Convert to hex strings\n  const privateKey = keyPair.getPrivate('hex');\n  const publicKey = keyPair.getPublic('hex');\n  \n  return {\n    privateKey,\n    publicKey\n  };\n};\n\n/**\n * Get public key from private key\n */\nexport const getPublicKey = (privateKey: string): string => {\n  const keyPair = ec.keyFromPrivate(privateKey);\n  return keyPair.getPublic('hex');\n};\n\n/**\n * Signs data with a private key\n */\nexport const sign = (data: string, privateKey: string): string => {\n  const keyPair = ec.keyFromPrivate(privateKey);\n  const hash = crypto.createHash('sha256').update(data).digest();\n  const signature = keyPair.sign(hash);\n  return signature.toDER('hex');\n};\n\n/**\n * Verifies a signature using public key\n */\nexport const verify = (data: string, signature: string, publicKey: string): boolean => {\n  try {\n    const keyPair = ec.keyFromPublic(publicKey, 'hex');\n    const hash = crypto.createHash('sha256').update(data).digest();\n    return keyPair.verify(hash, signature);\n  } catch (error) {\n    console.error('Verification error:', error);\n    return false;\n  }\n}; ", "import crypto from 'crypto';\nimport { KeyPair, generateKeyPair, sign } from './keyPair';\nimport { \n  Transaction, \n  TransactionInput, \n  TransactionOutput,\n  UnspentOutput\n} from '@yacoin/core/src/transaction/transactionUtils';\n\n/**\n * Type definition for a wallet\n */\nexport type Wallet = {\n  address: string;\n  keyPair: KeyPair;\n};\n\n/**\n * Creates a wallet address from public key\n * Using RIPEMD-160 of SHA-256 hash of the public key (similar to Bitcoin)\n */\nexport const createWalletAddress = (publicKey: string): string => {\n  // First hash with SHA-256\n  const publicKeyHash = crypto.createHash('sha256').update(publicKey).digest();\n  \n  // Then hash with RIPEMD-160\n  return crypto.createHash('ripemd160').update(publicKeyHash).digest('hex');\n};\n\n/**\n * Creates a new wallet with key pair and address\n */\nexport const createWallet = (): Wallet => {\n  const keyPair = generateKeyPair();\n  const address = createWalletAddress(keyPair.publicKey);\n  \n  return {\n    address,\n    keyPair\n  };\n};\n\n/**\n * Creates a transaction using the wallet's key pair\n */\nexport const createTransaction = (\n  wallet: Wallet,\n  recipientAddress: string,\n  amount: number,\n  availableUtxos: UnspentOutput[]\n): Transaction | null => {\n  \n  // Find sufficient UTXOs that belong to this wallet\n  const senderUtxos = availableUtxos.filter(utxo => utxo.address === wallet.address);\n  \n  const totalInputAmount = senderUtxos.reduce((sum, utxo) => sum + utxo.amount, 0);\n  \n  if (totalInputAmount < amount) {\n    console.error('Error: Insufficient funds in wallet.');\n    return null;\n  }\n  \n  const outputs: TransactionOutput[] = [];\n  \n  // Output for the recipient\n  outputs.push({ address: recipientAddress, amount });\n  \n  // Output for change (if any)\n  const changeAmount = totalInputAmount - amount;\n  if (changeAmount > 0) {\n    outputs.push({ address: wallet.address, amount: changeAmount });\n  }\n  \n  const timestamp = Date.now();\n  \n  // Create the unsigned transaction structure\n  const txToSign = {\n    inputs: senderUtxos.map(utxo => ({\n      transactionOutputId: utxo.transactionOutputId,\n      outputIndex: utxo.outputIndex,\n    })),\n    outputs,\n    timestamp,\n  };\n  \n  // Calculate transaction ID\n  const txDataString = JSON.stringify(txToSign.inputs) +\n                     JSON.stringify(txToSign.outputs) +\n                     txToSign.timestamp;\n  const txId = crypto.createHash('sha256').update(txDataString).digest('hex');\n  \n  // Sign each input\n  const inputs: TransactionInput[] = senderUtxos.map((utxo, index) => {\n    // Data to sign: txId + output reference + output amount\n    const dataToSign = txId + utxo.transactionOutputId + utxo.outputIndex + utxo.amount;\n    const signature = sign(dataToSign, wallet.keyPair.privateKey);\n    \n    return {\n      transactionOutputId: utxo.transactionOutputId,\n      outputIndex: utxo.outputIndex,\n      signature\n    };\n  });\n  \n  return {\n    id: txId,\n    inputs,\n    outputs,\n    timestamp\n  };\n}; ", "import { verify } from './keyPair';\nimport { createWalletAddress } from './wallet';\n\n/**\n * Verifies a transaction signature\n * \n * @param data - The data that was signed\n * @param signature - The signature to verify\n * @param address - The wallet address\n * @param publicKeyInHex - The public key in hex format\n * @returns boolean - Whether the signature is valid\n */\nexport const verifySignature = (\n  data: string,\n  signature: string,\n  address: string,\n  publicKeyInHex: string\n): boolean => {\n  // First verify that the provided public key corresponds to the address\n  const calculatedAddress = createWalletAddress(publicKeyInHex);\n  if (calculatedAddress !== address) {\n    console.error('Public key does not match address');\n    return false;\n  }\n  \n  // Then verify the signature against the data and public key\n  return verify(data, signature, publicKeyInHex);\n};\n\n/**\n * Verifies a transaction input signature\n * \n * This is a simpler version that will be called from the core package\n * It doesn't require direct access to cryptographic implementation\n * \n * @param txId - The transaction ID\n * @param outputId - The referenced output ID\n * @param outputIndex - The referenced output index\n * @param amount - The amount being spent\n * @param signature - The signature to verify\n * @param publicKey - The public key to verify against\n * @returns boolean - Whether the signature is valid\n */\nexport const verifyTransactionInputSignature = (\n  txId: string,\n  outputId: string,\n  outputIndex: number,\n  amount: number,\n  signature: string,\n  publicKey: string\n): boolean => {\n  // Reconstruct the data that would have been signed\n  const dataToVerify = txId + outputId + outputIndex + amount;\n  \n  // Generate the wallet address from the public key\n  const address = createWalletAddress(publicKey);\n  \n  // Verify the signature\n  return verifySignature(dataToVerify, signature, address, publicKey);\n}; "],
  "mappings": "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",
  "names": ["elliptic", "crypto", "import_crypto", "crypto"]
}
